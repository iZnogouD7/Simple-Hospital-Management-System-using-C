import React, { useState, useEffect } from "react";
import "./App.css";

const App = () => {
  const [tasks, setTasks] = useState([]);
  const [day, setDay] = useState("");
  const [date, setDate] = useState("");
  const [formData, setFormData] = useState({
    text: "",
    subtask: "",
    dueDate: "",
    priority: "Medium",
    category: "General"
  });
  const [sortType, setSortType] = useState("newest");

  useEffect(() => {
    // Load tasks from localStorage
    try {
      const savedTasks = JSON.parse(localStorage.getItem("tasks")) || [];
      setTasks(savedTasks);
    } catch (error) {
      console.error("Failed to load tasks from localStorage", error);
      setTasks([]);
    }

    // Set up day and date
    const today = new Date();
    const weekday = new Intl.DateTimeFormat("en-US", { weekday: "long" }).format(today);
    const month = new Intl.DateTimeFormat("en-US", { month: "long" }).format(today);
    const dayNum = today.getDate();
    const year = today.getFullYear();
    setDay(weekday);
    setDate(`${month} ${dayNum}, ${year}`);
  }, []);

  useEffect(() => {
    // Save tasks to localStorage whenever they change
    try {
      localStorage.setItem("tasks", JSON.stringify(tasks));
    } catch (error) {
      console.error("Failed to save tasks to localStorage", error);
    }
  }, [tasks]);

  const handleChange = e => {
    const { name, value } = e.target;
    setFormData(prev => ({ ...prev, [name]: value }));
  };

  const handleSubmit = e => {
    e.preventDefault();
    if (!formData.text.trim()) return alert("Please enter a task.");
    
    const newTask = {
      ...formData,
      completed: false,
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
      id: Date.now()
    };
    
    const updatedTasks = [...tasks, newTask];
    setTasks(updatedTasks);
    setFormData({ 
      text: "", 
      subtask: "", 
      dueDate: "", 
      priority: "Medium", 
      category: "General" 
    });
  };

  const handleToggle = id => {
    const updatedTasks = tasks.map(task =>
      task.id === id ? { 
        ...task, 
        completed: !task.completed, 
        updatedAt: new Date().toISOString() 
      } : task
    );
    setTasks(updatedTasks);
  };

  const handleDelete = id => {
    if (window.confirm("Are you sure you want to delete this task?")) {
      const updatedTasks = tasks.filter(task => task.id !== id);
      setTasks(updatedTasks);
    }
  };

  // Sort tasks
  const sortedTasks = [...tasks];
  const priorityOrder = { High: 3, Medium: 2, Low: 1 };

  if (sortType === "newest") {
    sortedTasks.sort((a, b) => new Date(b.updatedAt) - new Date(a.updatedAt));
  } else if (sortType === "oldest") {
    sortedTasks.sort((a, b) => new Date(a.updatedAt) - new Date(b.updatedAt));
  } else if (sortType === "priorityHighLow") {
    sortedTasks.sort((a, b) => priorityOrder[b.priority] - priorityOrder[a.priority]);
  } else if (sortType === "priorityLowHigh") {
    sortedTasks.sort((a, b) => priorityOrder[a.priority] - priorityOrder[b.priority]);
  }

  return (
    <div className="container">
      <h1>Today's To-Do List</h1>
      <p>
        <strong>{day}</strong> ‚Äî {date}
      </p>

      <form className="form-section" onSubmit={handleSubmit}>
        <input 
          name="text" 
          value={formData.text} 
          onChange={handleChange} 
          placeholder="Task" 
          required
        />
        <input 
          name="subtask" 
          value={formData.subtask} 
          onChange={handleChange} 
          placeholder="Subtask (optional)" 
        />
        <input 
          type="date" 
          name="dueDate" 
          value={formData.dueDate} 
          onChange={handleChange} 
        />
        <select 
          name="category" 
          value={formData.category} 
          onChange={handleChange}
        >
          <option value="General">General</option>
          <option value="Work">Work</option>
          <option value="Personal">Personal</option>
        </select>
        <select 
          name="priority" 
          value={formData.priority} 
          onChange={handleChange}
        >
          <option value="Low">Low</option>
          <option value="Medium">Medium</option>
          <option value="High">High</option>
        </select>
        <button type="submit">Add Task</button>
        <select 
          value={sortType} 
          onChange={e => setSortType(e.target.value)}
        >
          <option value="newest">Newest</option>
          <option value="oldest">Oldest</option>
          <option value="priorityHighLow">Priority High ‚Üí Low</option>
          <option value="priorityLowHigh">Priority Low ‚Üí High</option>
        </select>
      </form>

      <div className="task-layout">
        <div className="task-column">
          <h2>üìù Uncompleted Tasks</h2>
          <ul>
            {sortedTasks.filter(t => !t.completed).map(task => (
              <li key={task.id} className={`priority-${task.priority}`}>
                <input 
                  type="checkbox" 
                  checked={false} 
                  onChange={() => handleToggle(task.id)} 
                />
                <div className="task-body">
                  <strong>{task.text}</strong>
                  {task.subtask && <div>üîπ {task.subtask}</div>}
                  <div className="task-details">
                    üìÅ {task.category} | üóì Due: {task.dueDate || "N/A"} | ‚è≥ {task.priority}
                  </div>
                </div>
                <button 
                  className="delete-btn" 
                  onClick={() => handleDelete(task.id)}
                >
                  ‚úñ
                </button>
              </li>
            ))}
          </ul>
        </div>

        <div className="task-column">
          <h2>‚úÖ Completed Tasks</h2>
          <ul>
            {sortedTasks.filter(t => t.completed).map(task => (
              <li key={task.id} className={`priority-${task.priority} completed`}>
                <input 
                  type="checkbox" 
                  checked={true} 
                  onChange={() => handleToggle(task.id)} 
                />
                <div className="task-body">
                  <strong>{task.text}</strong>
                  {task.subtask && <div>üîπ {task.subtask}</div>}
                  <div className="task-details">
                    üìÅ {task.category} | üóì Due: {task.dueDate || "N/A"} | ‚è≥ {task.priority}
                  </div>
                </div>
                <button 
                  className="delete-btn" 
                  onClick={() => handleDelete(task.id)}
                >
                  ‚úñ
                </button>
              </li>
            ))}
          </ul>
        </div>
      </div>
    </div>
  );
};

export default App;



body {
  font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
  background-color: #f5f5f5;
  margin: 0;
  padding: 0;
}

.container {
  max-width: 1200px;
  margin: 0 auto;
  padding: 20px;
}

h1 {
  color: #333;
  text-align: center;
}

p {
  text-align: center;
  color: #666;
  margin-bottom: 30px;
}

.form-section {
  display: flex;
  flex-wrap: wrap;
  gap: 10px;
  margin-bottom: 30px;
  background: #fff;
  padding: 20px;
  border-radius: 8px;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

.form-section input,
.form-section select,
.form-section button {
  padding: 10px;
  border: 1px solid #ddd;
  border-radius: 4px;
  font-size: 16px;
}

.form-section input[type="text"],
.form-section input[type="date"] {
  flex: 1;
  min-width: 200px;
}

.form-section button {
  background-color: #4CAF50;
  color: white;
  border: none;
  cursor: pointer;
  transition: background-color 0.3s;
}

.form-section button:hover {
  background-color: #45a049;
}

.task-layout {
  display: flex;
  gap: 20px;
}

.task-column {
  flex: 1;
  background: #fff;
  padding: 20px;
  border-radius: 8px;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

.task-column h2 {
  border-bottom: 2px solid #eee;
  padding-bottom: 10px;
  color: #444;
}

ul {
  list-style: none;
  padding: 0;
}

li {
  display: flex;
  align-items: center;
  padding: 15px;
  margin-bottom: 10px;
  border-radius: 4px;
  background-color: #f9f9f9;
  transition: all 0.3s;
}

li:hover {
  background-color: #f0f0f0;
}

li.completed {
  opacity: 0.7;
}

li.completed .task-body strong {
  text-decoration: line-through;
  color: #888;
}

.priority-High {
  border-left: 4px solid #f44336;
}

.priority-Medium {
  border-left: 4px solid #ff9800;
}

.priority-Low {
  border-left: 4px solid #4CAF50;
}

.task-body {
  flex: 1;
  margin: 0 15px;
}

.task-details {
  font-size: 0.8em;
  color: #666;
  margin-top: 5px;
}

.delete-btn {
  background: none;
  border: none;
  color: #888;
  cursor: pointer;
  font-size: 1.2em;
  padding: 5px 10px;
}

.delete-btn:hover {
  color: #f44336;
}

input[type="checkbox"] {
  transform: scale(1.3);
  margin-right: 10px;
}

@media (max-width: 768px) {
  .task-layout {
    flex-direction: column;
  }
  
  .form-section {
    flex-direction: column;
  }
}



def test_password_masking_toggle(driver):
    login_page = LoginPage(driver)
    driver.get(login_page.url)
    
    password_field = login_page.find_element(LoginPageLocators.password_field)
    toggle_button = login_page.find_element((By.CSS_SELECTOR, ".password-visibility-toggle"))
    
    # Verify password is masked by default
    assert password_field.get_attribute("type") == "password", "Password should be masked initially"
    
    # Click toggle and verify unmasking
    toggle_button.click()
    assert password_field.get_attribute("type") == "text", "Password should be visible after toggle"
    
    # Click again and verify re-masking
    toggle_button.click()
    assert password_field.get_attribute("type") == "password", "Password should re-mask after second toggle"


def test_default_sorting_az(login_and_go_to_product_page):
    product_page = login_and_go_to_product_page
    items = product_page.get_all_items_names()
    
    # Verify items are sorted A-Z by default
    assert items == sorted(items), f"Items not sorted A-Z by default. First mismatch: {next((x,y) for x,y in zip(items, sorted(items)) if x != y)}"
@pytest.mark.parametrize("filter_option,expected_sort", [
    ("Name (A to Z)", "asc"),
    ("Name (Z to A)", "desc"),
    ("Price (low to high)", "asc"),
    ("Price (high to low)", "desc")
])
def test_all_sorting_filters(login_and_go_to_product_page, filter_option, expected_sort):
    product_page = login_and_go_to_product_page
    
    # Apply filter
    product_page.select_filter_button(filter_option)
    
    # Get appropriate values to compare
    if "Price" in filter_option:
        values = product_page.get_all_items_price()
    else:
        values = product_page.get_all_items_names()
    
    # Verify sorting
    if expected_sort == "asc":
        assert values == sorted(values), f"{filter_option} not working"
    else:
        assert values == sorted(values, reverse=True), f"{filter_option} not working"

@pytest.mark.parametrize("firstname,lastname,zipcode", [
    ("T√©st@User", "J√∂hn$Doe", "123!@#"),
    ("–û–ª–µ–≥", "ÍπÄÏ≤†Ïàò", "Êù±‰∫¨")
])
def test_special_character_checkout(driver, firstname, lastname, zipcode):
    # Full checkout flow with special chars
    login_page = LoginPage(driver)
    login_page.login(valid_user, valid_pass)
    
    product_page = ProductPage(driver)
    product_page.add_single_item(ProductPageLocators.add_back_pack_path)
    product_page.click_on_cart_button()
    
    cart_page = CartPage(driver)
    cart_page.click_checkout_button()
    
    checkout_page = CheckoutPage(driver)
    checkout_page.enter_checkout_info(firstname, lastname, zipcode)
    
    assert "checkout-step-two" in driver.current_url, \
        f"Checkout failed with special chars: {firstname}/{lastname}/{zipcode}"
def test_checkout_field_limits(driver):
    checkout_page = go_to_checkout_page(driver)  # Implement this fixture
    
    # Test first name max length (assuming 50 chars)
    long_name = "A" * 51
    checkout_page.type_in_element(CheckoutPageLocators.first_name_path, long_name)
    entered_text = checkout_page.find_element(CheckoutPageLocators.first_name_path).get_attribute("value")
    assert len(entered_text) == 50, "First name should truncate at 50 chars"


# tests/test_cart_integrity.py
def test_added_items_match_cart_contents(driver):
    # Setup
    login_page = LoginPage(driver)
    product_page = ProductPage(driver)
    cart_page = CartPage(driver)
    
    # Test data
    test_items = [
        (ProductPageLocators.add_back_pack_path, "Sauce Labs Backpack", 29.99),
        (ProductPageLocators.add_bike_light_path, "Sauce Labs Bike Light", 9.99)
    ]
    
    # Add items
    for locator, _, _ in test_items:
        product_page.add_single_item(locator)
    
    # Verify cart
    product_page.click_on_cart_button()
    cart_items = cart_page.get_cart_items()  # Implement this method
    
    for i, (_, expected_name, expected_price) in enumerate(test_items):
        assert cart_items[i]['name'] == expected_name, \
            f"Item {i} name mismatch. Expected {expected_name}, got {cart_items[i]['name']}"
        assert cart_items[i]['price'] == expected_price, \
            f"Item {i} price mismatch. Expected {expected_price}, got {cart_items[i]['price']}"
# pages/cart_page.py
def get_cart_items(self):
    items = []
    elements = self.find_elements((By.CLASS_NAME, "cart_item"))
    for element in elements:
        items.append({
            'name': element.find_element(By.CLASS_NAME, "inventory_item_name").text,
            'price': float(element.find_element(By.CLASS_NAME, "inventory_item_price").text.replace('$', '')),
            'quantity': int(element.find_element(By.CLASS_NAME, "cart_quantity").text)
        })
    return items
# tests/test_price_calculations.py
def test_checkout_price_calculations(driver):
    # Setup
    login_page = LoginPage(driver)
    product_page = ProductPage(driver)
    checkout_page = CheckoutPage(driver)
    
    # Add known items
    product_page.add_single_item(ProductPageLocators.add_back_pack_path)  # $29.99
    product_page.add_single_item(ProductPageLocators.add_bike_light_path)  # $9.99
    product_page.click_on_cart_button()
    cart_page.click_checkout_button()
    
    # Enter checkout info
    checkout_page.enter_checkout_info("John", "Doe", "12345")
    
    # Verify calculations
    item_total = checkout_page.get_summary_value("Item total")  # $39.98
    tax = checkout_page.get_summary_value("Tax")  # $3.20 (8% of $39.98)
    total = checkout_page.get_summary_value("Total")  # $43.18
    
    assert tax == round(item_total * 0.08, 2), \
        f"Tax calculation wrong. Expected {round(item_total*0.08,2)}, got {tax}"
    assert total == item_total + tax, \
        f"Total calculation wrong. Expected {item_total+tax}, got {total}"
# pages/checkout_page.py
def get_summary_value(self, label):
    element = self.find_element((By.XPATH, f"//div[contains(text(),'{label}')]/following-sibling::div"))
    return float(element.text.replace('$', ''))












package com.TicketSystem.TicketSystem.controller;

import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/admin")
@RequiredArgsConstructor
public class AdminController {
    private final AdminService adminService;

    @PostMapping("/support-staff")
    public ResponseEntity<?> createSupportStaff(@RequestBody SupportStaffRequestDto dto) {
        return adminService.createSupportStaff(dto);
    }

    @PutMapping("/support-staff/{id}")
    public ResponseEntity<?> updateSupportStaff(@PathVariable Long id, @RequestBody SupportStaffRequestDto dto) {
        return adminService.updateSupportStaff(id, dto);
    }

    @GetMapping("/support-staff")
    public ResponseEntity<?> viewSupportStaff() {
        return adminService.viewSupportStaff();
    }

    @PostMapping("/assign-ticket")
    public ResponseEntity<?> assignTicket(@RequestBody AssignTicketRequestDto dto) {
        return adminService.assignTicketToStaff(dto);
    }

    @GetMapping("/tickets")
    public ResponseEntity<?> viewAllTickets() {
        return adminService.viewAllIssuedTickets();
    }

    @GetMapping("/users")
    public ResponseEntity<?> viewAllUsers() {
        return adminService.viewAllRegisteredUsers();
    }

}

package com.TicketSystem.TicketSystem.controller;


import com.TicketSystem.TicketSystem.services.serviceImpl.AuthServiceImpl;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/api/auth")
@RequiredArgsConstructor
public class AuthController {
    private final AuthServiceImpl authServiceImpl;

    @PostMapping("/register")
    public ResponseEntity<?> register(@RequestBody RegisterRequestDto dto) {
        return authServiceImpl.register(dto);
    }

    @PostMapping("/login")
    public ResponseEntity<?> login(@RequestBody LoginRequestDto dto) {
        return authServiceImpl.login(dto);
    }

    @PostMapping("/logout")
    public ResponseEntity<?> logout() {
        return authServiceImpl.logout();
    }
}
package com.TicketSystem.TicketSystem.controller;


import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/staff")
@RequiredArgsConstructor
public class SupportStaffController {
    private final SupportStaffService supportStaffService;

    @GetMapping("/tickets")
    public ResponseEntity<?> viewAssignedTickets() {
        return supportStaffService.viewAssignedTickets();
    }

    @PutMapping("/tickets/{id}/status")
    public ResponseEntity<?> updateTicketStatus(@PathVariable Long id, @RequestBody String newStatus) {
        return supportStaffService.updateTicketStatus(id, newStatus);
    }
}
package com.TicketSystem.TicketSystem.controller;

import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/tickets")
@RequiredArgsConstructor
public class TicketController {
    private final TicketService ticketService;

    @PostMapping
    public ResponseEntity<?> createTicket(@RequestBody TicketRequestDto dto) {
        return ticketService.createTicket(dto);
    }

    @PutMapping("/{id}")
    public ResponseEntity<?> updateTicket(@PathVariable Long id, @RequestBody TicketRequestDto dto) {
        return ticketService.updateTicket(id, dto);
    }

    @GetMapping
    public ResponseEntity<?> viewAllTickets() {
        return ticketService.viewAllTickets();
    }

    @GetMapping("/{id}")
    public ResponseEntity<?> viewTicket(@PathVariable Long id) {
        return ticketService.viewTicket(id);
    }

    @DeleteMapping("/{id}")
    public ResponseEntity<?> deleteTicket(@PathVariable Long id) {
        return ticketService.deleteTicket(id);
    }
}
Servcie
package com.TicketSystem.TicketSystem.services.serviceImpl;


import com.TicketSystem.TicketSystem.repositories.RoleRepository;
import com.TicketSystem.TicketSystem.repositories.UserRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;

@Service
@RequiredArgsConstructor
public class AuthServiceImpl {
    private final UserRepository userRepository;
    private final RoleRepository roleRepository;
    private final PasswordEncoder passwordEncoder;

    public ResponseEntity<?> register(RegisterRequestDto dto) {
        Role role = roleRepository.findByRoleName("CUSTOMER")
                .orElseThrow(() -> new RuntimeException("Role not found"));

        User user = User.builder()
                .fullName(dto.getFullName())
                .email(dto.getEmail())
                .password(passwordEncoder.encode(dto.getPassword()))
                .address(dto.getAddress())
                .contactNo(dto.getContactNo())
                .status(UserStatus.ACTIVE)
                .role(role)
                .build();

        userRepository.save(user);
        return ResponseEntity.ok("User registered successfully");
    }

    public ResponseEntity<?> login(LoginRequestDto dto) {
        // Stub logic ‚Äì normally, you'd authenticate and generate JWT token here
        return ResponseEntity.ok("Login successful (stub)");
    }

    public ResponseEntity<?> logout() {
        // Stub logic for logout
        return ResponseEntity.ok("Logout successful (stub)");
    }
}
package com.TicketSystem.TicketSystem.services.serviceImpl;

import com.TicketSystem.TicketSystem.services.TicketService;

public class TicketServiceImpl implements TicketService {
    private final TicketRepository ticketRepository;
    private final UserRepository userRepository;
    private final TicketTypeRepository ticketTypeRepository;

    public ResponseEntity<?> createTicket(TicketRequestDto dto) {
        User user = userRepository.findById(dto.getUserId()).orElseThrow();
        TicketType ticketType = ticketTypeRepository.findById(dto.getTicketTypeId()).orElseThrow();

        Ticket ticket = Ticket.builder()
                .title(dto.getTitle())
                .description(dto.getDescription())
                .priority(dto.getPriority())
                .status(TicketStatus.OPEN)
                .user(user)
                .ticketType(ticketType)
                .build();

        ticketRepository.save(ticket);
        return ResponseEntity.ok(ticket);
    }

    public ResponseEntity<?> updateTicket(Long id, TicketRequestDto dto) {
        Ticket ticket = ticketRepository.findById(id).orElseThrow();
        ticket.setTitle(dto.getTitle());
        ticket.setDescription(dto.getDescription());
        ticket.setPriority(dto.getPriority());
        ticketRepository.save(ticket);
        return ResponseEntity.ok(ticket);
    }

    public ResponseEntity<?> viewAllTickets() {
        List<Ticket> tickets = ticketRepository.findAll();
        return ResponseEntity.ok(tickets);
    }

    public ResponseEntity<?> viewTicket(Long id) {
        Ticket ticket = ticketRepository.findById(id).orElseThrow();
        return ResponseEntity.ok(ticket);
    }

    public ResponseEntity<?> deleteTicket(Long id) {
        ticketRepository.deleteById(id);
        return ResponseEntity.ok("Ticket deleted successfully");
    }
}
models
package com.TicketSystem.TicketSystem.models;

import com.TicketSystem.TicketSystem.base.BaseEntity;
import jakarta.persistence.Entity;
import jakarta.persistence.Table;
import lombok.*;

@Entity
@Table(name = "Roles_Table")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class Role extends BaseEntity {
    private String roleName;

//    private List<User> user;
}
package com.TicketSystem.TicketSystem.models;

import jakarta.persistence.*;

@Entity
@Table(name = "Support_Staff_Table")
public class SupportStaff {
    @Id
    private Long id;

    @OneToOne
    @MapsId
    @JoinColumn(name = "User_Id")
    private User user;

    private boolean isAvailable;
}
package com.TicketSystem.TicketSystem.models;

import com.TicketSystem.TicketSystem.base.AuditBaseEntity;
import jakarta.persistence.*;
import lombok.*;

@Entity
@Table(name = "Tickets_Table")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class Ticket extends AuditBaseEntity {
    private String title;
    private String description;

    @Enumerated(EnumType.STRING)
    private TicketStatus status;

    @ManyToOne
    @JoinColumn(name = "ticket_type_id")
    private TicketType ticketType;


    @Enumerated(EnumType.STRING)
    private TicketPriority priority;

    @ManyToOne
    @JoinColumn(name = "customer_id")
    private User user;

    @ManyToOne
    @JoinColumn(name = "support_staff_id")
    private SupportStaff supportStaff;
}
package com.TicketSystem.TicketSystem.models;

public enum TicketPriority {
    LOW,
    MEDIUM,
    HIGH
}
package com.TicketSystem.TicketSystem.models;

public enum TicketStatus {
    PENDING,
    IN_PROGRESS,
    RESOLVED,
    CLOSED
}
package com.TicketSystem.TicketSystem.models;

import com.TicketSystem.TicketSystem.base.BaseEntity;
import jakarta.persistence.Entity;
import jakarta.persistence.Table;
import lombok.*;

@Entity
@Table(name = "Ticket_Type_Table")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class TicketType extends BaseEntity {
    private String type;
}
package com.TicketSystem.TicketSystem.models;

import com.TicketSystem.TicketSystem.base.AuditBaseEntity;
import jakarta.persistence.*;
import lombok.*;

import java.util.List;

@Entity
@Table(name = "Users_Table")
//@Data
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class User extends AuditBaseEntity {
    private String fullName;
    private String email;
    private String password;
    private String address;
    private String contactNo;

    @ManyToOne
    @JoinColumn(name = "role_id")
    private Role role;

    @OneToMany(mappedBy = "user")
    private List<Ticket> customerTicket;

    @Enumerated(EnumType.STRING)
    private UserStatus status;
}
package com.TicketSystem.TicketSystem.models;

//public class UserStatus {
//}
public enum UserStatus{
    ACTIVE,INACTIVE,BLOCKED
}
package com.example.CustomerSupportTicket.controllers;

import com.example.CustomerSupportTicket.base.APIResponse;
import com.example.CustomerSupportTicket.dtos.requestdto.RegisterRequestDto;
import com.example.CustomerSupportTicket.dtos.responsedto.*;
import com.example.CustomerSupportTicket.services.AdminService;
import com.example.CustomerSupportTicket.utils.ResponseUtil;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/v1/admin")
@RequiredArgsConstructor
public class AdminController {

    private final AdminService adminService;

    @PreAuthorize("hasRole('ADMIN')")
    @PostMapping("/create-staff")
    public ResponseEntity<APIResponse<NewStaffResponseDto>> createStaffUser(@RequestBody RegisterRequestDto reqDto) {
        if (reqDto == null) {
            throw new NullPointerException("Empty....!!");
        }
        NewStaffResponseDto responseDto = adminService.createStaffUser(reqDto);
        return ResponseUtil.success(responseDto, "Staff Created Successfully", HttpStatus.CREATED);
    }

    @GetMapping("/staff")
    public ResponseEntity<APIResponse<List<UserResDto>>> getAllStaff(){

        List<UserResDto> resDtoList = adminService.getAllStaff();

        return ResponseUtil.success(resDtoList,"Staff Fetch Successfully",HttpStatus.OK);
    }

    @GetMapping("/staff/{id}")
    public ResponseEntity<APIResponse<UserDetailResDto>> getStaffById(@PathVariable Long id){
        UserDetailResDto resDto = adminService.getStaffById(id);
        return ResponseUtil.success(resDto,"Staff Fetch Successfully",HttpStatus.OK);
    }



    @PutMapping("/staff/{id}")
    public ResponseEntity<APIResponse<UserDetailResDto>> updateStaffUser(){

        return null;
    }


    @GetMapping("/tickets")
    public ResponseEntity<APIResponse<List<TicketResDto>>> getAllTickets() {
        List<TicketResDto> resDtoList = adminService.getAllTickets();

        return ResponseUtil.success(resDtoList, "All Tickets", HttpStatus.OK);
    }

    @GetMapping("/ticket/{id}")
    public ResponseEntity<APIResponse<TicketDetailResDto>> getTicketById(@PathVariable Long id) {
        TicketDetailResDto resDtoList = adminService.getTicketById(id);

        return ResponseUtil.success(resDtoList, "All Tickets", HttpStatus.OK);
    }


    @PutMapping("/ticket/{id}/assign/{staffId}")
    public ResponseEntity<APIResponse<TicketDetailResDto>> assignTicket(@PathVariable Long id,
    @PathVariable Long staffId) {
       TicketDetailResDto resDto =  adminService.assignTicket(id, staffId);
            return ResponseUtil.success(resDto, "Ticket Assigned", HttpStatus.OK);
//        return ResponseUtil.error(null,"Error Occurred", HttpStatus.BAD_REQUEST);
    }

    @GetMapping("/users")
    public ResponseEntity<APIResponse<List<UserResDto>>> getAllCustomers(){
        List<UserResDto> resDtoList = adminService.getAllCustomer();

        return ResponseUtil.success(resDtoList,"Customers Fetch Successfully",HttpStatus.OK);
    }

    @GetMapping("/users/{id}")
    public ResponseEntity<APIResponse<UserDetailResDto>> getCustomerById(@PathVariable Long id){
        UserDetailResDto resDto = adminService.getCustomerById(id);
        return ResponseUtil.success(resDto,"Customer Fetch Successfully",HttpStatus.OK);
    }
}







import com.fasterxml.jackson.databind.ObjectMapper;
import com.ragnar.main.API.DTOs.Auth.LoginDTO;
import com.ragnar.main.API.DTOs.Book.CreateBookDTO;
import com.ragnar.main.Application.IRepositories.IUserRepository;
import com.ragnar.main.Application.IServices.IAuthService;
import com.ragnar.main.Domain.Enums.GenreType;
import com.ragnar.main.Util.Helpers.DateHelper;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.jdbc.AutoConfigureTestDatabase;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.http.MediaType;
import org.springframework.test.context.ActiveProfiles;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.test.web.servlet.request.MockMvcRequestBuilders;
 
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;
 
@SpringBootTest
@AutoConfigureMockMvc
@ActiveProfiles("test")
class BookControllerTest {
    @Autowired
    private MockMvc mvc;
 
    @Autowired
    private ObjectMapper mapper;
 
    @Autowired
    private IUserRepository userRepository;
 
    @Autowired
    private IAuthService authService;
 
    private String jwtToken;
 
    @BeforeEach
    void setup() {
        var model = LoginDTO.builder()
                .username("superadmin")
                .password("superadmin@123")
                .build();
        var response = authService.LoginUser(model);
        jwtToken = response.getData().getToken();
    }
 
    @Test
    void createBook() throws Exception {
        var dto = CreateBookDTO.builder()
                .bookName("Test Book")
                .publicationYear(DateHelper.ParseDate("2025-06-24"))
                .Genre(GenreType.ACTION)
                .Price(1000)
                .authorId(1L)
                .build();
 
        mvc.perform(MockMvcRequestBuilders
            .post("/api/v1/Book")
            .header("Authorization", "Bearer " + jwtToken)
            .contentType(MediaType.APPLICATION_JSON)
            .content(mapper.writeValueAsString(dto))
        )
        .andExpect(status().isOk())
        .andExpect(jsonPath("$.success").value(true))
        .andExpect(jsonPath("$.data").exists());
    }
 
    @Test
    void getAllBooks() {
    }
 
    @Test
    void deleteBook() {
    }
}
--------------------------------------------------------------------
//package com.example.CustomerSupportTicket.controllers;
//
//import com.example.CustomerSupportTicket.dtos.requestdto.LoginReqDto;
//import com.example.CustomerSupportTicket.dtos.requestdto.RegisterRequestDto;
//import com.fasterxml.jackson.databind.ObjectMapper;
//import org.junit.jupiter.api.BeforeEach;
//import org.junit.jupiter.api.Test;
//import org.springframework.beans.factory.annotation.Autowired;
//import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
//import org.springframework.boot.test.context.SpringBootTest;
//import org.springframework.http.MediaType;
//import org.springframework.test.context.ActiveProfiles;
//import org.springframework.test.web.servlet.MockMvc;
//import org.springframework.test.web.servlet.request.MockMvcRequestBuilders;
//
//import static org.junit.jupiter.api.Assertions.*;
//import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;
//
//@SpringBootTest
//@AutoConfigureMockMvc
//@ActiveProfiles("test")
//public class AdminControllerTest {
//    @Autowired
//    private MockMvc mvc;
//
//    @Autowired
//    private ObjectMapper mapper;
//
//    private String jwtToken;
//    @Test
//    void contextLoads() {}
//    @BeforeEach
//    void setup() throws Exception {
//        var registerDto = new RegisterRequestDto("Admin", "admin@admin.com", "admin123", "Ktm", "9811111111");
//        mvc.perform(MockMvcRequestBuilders.post("/api/v1/auth/create-user")
//                .contentType(MediaType.APPLICATION_JSON)
//                .content(mapper.writeValueAsString(registerDto)));
//
//        var loginDto = new LoginReqDto("admin@admin.com", "admin123");
//        var loginResponse = mvc.perform(MockMvcRequestBuilders.post("/api/v1/auth/login")
//                        .contentType(MediaType.APPLICATION_JSON)
//                        .content(mapper.writeValueAsString(loginDto)))
//                .andReturn().getResponse().getContentAsString();
//
//        jwtToken = mapper.readTree(loginResponse).get("data").get("token").asText();
//    }
//    @Test
//    void createStaffUser() throws Exception{
//        var registerDto = new RegisterRequestDto("Staff Name", "staff@example.com", "staff123", "Kathmandu", "9800000000");
//
//        mvc.perform(MockMvcRequestBuilders.post("/api/v1/admin/create-staff")
//                        .header("Authorization", "Bearer " + jwtToken)
//                        .contentType(MediaType.APPLICATION_JSON)
//                        .content(mapper.writeValueAsString(registerDto)))
//                .andExpect(status().isCreated())
//                .andExpect(jsonPath("$.message").value("Staff Created Successfully"))
//                .andExpect(jsonPath("$.data").exists());
//    }
//
//    @Test
//    void getAllStaff() throws Exception {
//        mvc.perform(MockMvcRequestBuilders.get("/api/v1/admin/staff")
//                        .header("Authorization", "Bearer " + jwtToken))
//                .andExpect(status().isOk())
//                .andExpect(jsonPath("$.message").value("Staff Fetch Successfully"));
//    }
//
//    @Test
//    void getStaffById() throws Exception{
//        mvc.perform(MockMvcRequestBuilders.get("/api/v1/admin/staff/1")
//                        .header("Authorization", "Bearer " + jwtToken))
//                .andExpect(status().isOk())
//                .andExpect(jsonPath("$.message").value("Staff Fetch Successfully"));
//    }
//
//    @Test
//    void assignTicket() throws Exception{
//        mvc.perform(MockMvcRequestBuilders.put("/api/v1/admin/ticket/1/assign/2")
//                        .header("Authorization", "Bearer " + jwtToken))
//                .andExpect(status().isOk())
//                .andExpect(jsonPath("$.message").value("Ticket Assigned"));
//    }
//}

package com.example.CustomerSupportTicket.controllers;
import com.example.CustomerSupportTicket.dtos.requestdto.LoginReqDto;
import com.example.CustomerSupportTicket.dtos.requestdto.RegisterRequestDto;
import com.example.CustomerSupportTicket.models.Role;
import com.example.CustomerSupportTicket.repositories.RoleRepository;
import com.example.CustomerSupportTicket.repositories.UserRepository;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.http.MediaType;
import org.springframework.test.context.ActiveProfiles;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.test.web.servlet.request.MockMvcRequestBuilders;

import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;

@SpringBootTest
@AutoConfigureMockMvc
@ActiveProfiles("test")
class AdminControllerTest {

    @Autowired
    private MockMvc mvc;

    @Autowired
    private ObjectMapper mapper;

    private String adminToken;
    @Autowired
    private UserRepository userRepository;
    @Autowired
    private RoleRepository roleRepository;
    @BeforeEach
    void setupAdmin() throws Exception {
        // Register Admin
        Role adminRole=roleRepository.findByRoleName("ADMIN");
        if (adminRole == null) {
            adminRole = new Role();
            adminRole.setRoleName("ADMIN");
            roleRepository.save(adminRole);
        }
        var adminDto = new RegisterRequestDto(
                "Super Admin",
                "admin@example.com",
                "admin123",
                "KTM",
                "9800000000"
        );

        mvc.perform(MockMvcRequestBuilders.post("/api/v1/auth/create-user")
                .contentType(MediaType.APPLICATION_JSON)
                .content(mapper.writeValueAsString(adminDto)));

        // Login Admin
        var loginDto = new LoginReqDto("admin@example.com", "admin123");
        var loginRes = mvc.perform(MockMvcRequestBuilders.post("/api/v1/auth/login")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(mapper.writeValueAsString(loginDto)))
                .andReturn().getResponse().getContentAsString();

        adminToken = mapper.readTree(loginRes).get("data").get("token").asText();
    }

    @Test
    void getAllStaff() throws Exception {
        mvc.perform(MockMvcRequestBuilders.get("/api/v1/admin/staff")
                        .header("Authorization", "Bearer " + adminToken))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.message").value("Staff Fetch Successfully"));
    }
}



package com.example.CustomerSupportTicket.controllers;

import com.example.CustomerSupportTicket.dtos.requestdto.LoginReqDto;
import com.example.CustomerSupportTicket.dtos.requestdto.RegisterRequestDto;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.http.MediaType;
import org.springframework.test.context.ActiveProfiles;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.test.web.servlet.request.MockMvcRequestBuilders;

import static org.junit.jupiter.api.Assertions.*;

import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;


@SpringBootTest
@AutoConfigureMockMvc
@ActiveProfiles("test")
public class AuthControllerTest {
    @Autowired
    private MockMvc mvc;

    @Autowired
    private ObjectMapper mapper;
    @Test
    void createNewUser() throws Exception{
        var registerDto = new RegisterRequestDto("User Name", "user@example.com", "user123", "Pokhara", "9811111111");

        mvc.perform(MockMvcRequestBuilders.post("/api/v1/auth/create-user")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(mapper.writeValueAsString(registerDto)))
                .andExpect(status().isCreated())
                .andExpect(jsonPath("$.message").value("User Created Successfully"))
                .andExpect(jsonPath("$.data").exists());
    }

    @Test
    void loginUser() throws Exception {
        var loginDto = new LoginReqDto("user@example.com", "user123");

        mvc.perform(MockMvcRequestBuilders.post("/api/v1/auth/login")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(mapper.writeValueAsString(loginDto)))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.message").value("Login Successfull"))
                .andExpect(jsonPath("$.data.token").exists());
    }
}



package com.example.CustomerSupportTicket.controllers;

import com.example.CustomerSupportTicket.dtos.requestdto.LoginReqDto;
import com.example.CustomerSupportTicket.dtos.requestdto.RegisterRequestDto;
import com.example.CustomerSupportTicket.dtos.requestdto.TicketStatusReqDto;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.http.MediaType;
import org.springframework.test.context.ActiveProfiles;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.test.web.servlet.request.MockMvcRequestBuilders;

import static org.junit.jupiter.api.Assertions.*;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;


@SpringBootTest
@AutoConfigureMockMvc
@ActiveProfiles("test")
public class StaffControllerTest {
    @Autowired
    private MockMvc mvc;

    @Autowired
    private ObjectMapper mapper;

    private String jwtToken;
    void setup() throws Exception {
        var registerDto = new RegisterRequestDto("Staff User", "staff@staff.com", "staff123", "Pokhara", "9810000000");
        mvc.perform(MockMvcRequestBuilders.post("/api/v1/auth/create-user")
                .contentType(MediaType.APPLICATION_JSON)
                .content(mapper.writeValueAsString(registerDto)));

        var loginDto = new LoginReqDto("staff@staff.com", "staff123");
        var loginResponse = mvc.perform(MockMvcRequestBuilders.post("/api/v1/auth/login")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(mapper.writeValueAsString(loginDto)))
                .andReturn().getResponse().getContentAsString();

        jwtToken = mapper.readTree(loginResponse).get("data").get("token").asText();
    }

    @Test
    void getAssignedTickets() throws Exception {
        mvc.perform(MockMvcRequestBuilders.get("/api/v1/staff/tickets")
                        .header("Authorization", "Bearer " + jwtToken))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.message").value("Tickets Fetch Successful"));
    }

    @Test
    void getTicketById() throws Exception {
        mvc.perform(MockMvcRequestBuilders.get("/api/v1/staff/ticket/1")
                        .header("Authorization", "Bearer " + jwtToken))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.message").value("Ticket Fetched"));
    }

    @Test
    void updateTicketStatus() throws Exception{
        var statusDto = new TicketStatusReqDto("RESOLVED");

        mvc.perform(MockMvcRequestBuilders.put("/api/v1/staff/ticket/1")
                        .header("Authorization", "Bearer " + jwtToken)
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(mapper.writeValueAsString(statusDto)))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.message").value("Ticket Updated Successfully"));
    }
}



package com.example.CustomerSupportTicket.controllers;

import com.example.CustomerSupportTicket.dtos.requestdto.LoginReqDto;
import com.example.CustomerSupportTicket.dtos.requestdto.RegisterRequestDto;
import com.example.CustomerSupportTicket.dtos.requestdto.TicketReqDto;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.http.MediaType;
import org.springframework.test.context.ActiveProfiles;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.test.web.servlet.request.MockMvcRequestBuilders;

import static org.junit.jupiter.api.Assertions.*;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;

@SpringBootTest
@AutoConfigureMockMvc
@ActiveProfiles("test")
public class TicketControllerTest {
    @Autowired
    private MockMvc mvc;

    @Autowired
    private ObjectMapper mapper;

    private String jwtToken;
    @BeforeEach
    void setup() throws Exception {
        // Register admin user
        var registerDto = new RegisterRequestDto("Admin User", "admin@example.com", "admin123", "Kathmandu", "9800000000");
        mvc.perform(MockMvcRequestBuilders.post("/api/v1/auth/create-user")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(mapper.writeValueAsString(registerDto)))
                .andExpect(status().isCreated());

        // Login admin user
        var loginDto = new LoginReqDto("admin@example.com", "admin123");
        String loginContent = mapper.writeValueAsString(loginDto);
        var result = mvc.perform(MockMvcRequestBuilders.post("/api/v1/auth/login")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(loginContent))
                .andExpect(status().isOk())
                .andReturn();

        jwtToken = mapper.readTree(result.getResponse().getContentAsString())
                .get("data").get("token").asText();
    }

    @Test
    void createTicket() throws Exception{
        var ticketDto = new TicketReqDto("Title", "Desc", "Bug", "High");

        mvc.perform(MockMvcRequestBuilders.post("/api/v1/ticket")
                        .header("Authorization", "Bearer " + jwtToken)
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(mapper.writeValueAsString(ticketDto)))
                .andExpect(status().isCreated())
                .andExpect(jsonPath("$.message").value("Ticket Created"));
    }
}


package com.example.CustomerSupportTicket.controllers;

import com.example.CustomerSupportTicket.dtos.requestdto.LoginReqDto;
import com.example.CustomerSupportTicket.dtos.requestdto.RegisterRequestDto;
import com.example.CustomerSupportTicket.dtos.requestdto.TicketReqDto;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.http.MediaType;
import org.springframework.test.context.ActiveProfiles;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.test.web.servlet.request.MockMvcRequestBuilders;

import static org.junit.jupiter.api.Assertions.*;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;


@SpringBootTest
@AutoConfigureMockMvc
@ActiveProfiles("test")
public class UserControllerTest {
    @Autowired
    private MockMvc mvc;

    @Autowired
    private ObjectMapper mapper;

    private String jwtToken;
    private Long ticketId;
    @BeforeEach
    void setup() throws Exception {
        var registerDto = new RegisterRequestDto("Customer User", "customer@example.com", "cust123", "Bhaktapur", "9808888888");
        mvc.perform(MockMvcRequestBuilders.post("/api/v1/auth/create-user")
                .contentType(MediaType.APPLICATION_JSON)
                .content(mapper.writeValueAsString(registerDto)));

        var loginDto = new LoginReqDto("customer@example.com", "cust123");
        var loginResponse = mvc.perform(MockMvcRequestBuilders.post("/api/v1/auth/login")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(mapper.writeValueAsString(loginDto)))
                .andReturn().getResponse().getContentAsString();

        jwtToken = mapper.readTree(loginResponse).get("data").get("token").asText();
        // Create a new ticket
        var ticketDto = new TicketReqDto("Test Ticket", "This is a test", "Bug", "HIGH");
        var createResponse = mvc.perform(MockMvcRequestBuilders.post("/api/v1/ticket")
                        .header("Authorization", "Bearer " + jwtToken)
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(mapper.writeValueAsString(ticketDto)))
                .andReturn().getResponse().getContentAsString();
        System.out.println("Create Response: " + createResponse);

        // Save created ticket ID for use in tests
        ticketId = mapper.readTree(createResponse).get("data").get("id").asLong();
    }
    @Test
    void getAllTicket() throws Exception{
        mvc.perform(MockMvcRequestBuilders.get("/api/v1/customer/tickets")
                        .header("Authorization", "Bearer " + jwtToken))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.message").exists());
    }

    @Test
    void getTicketById() throws Exception{
        mvc.perform(MockMvcRequestBuilders.get("/api/v1/customer/ticket/"+ticketId)
                        .header("Authorization", "Bearer " + jwtToken))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.message").value("Ticket fetch Success"));

    }

    @Test
    void updateTicket() throws Exception{
        var updateDto = new TicketReqDto("Updated Title", "Updated Description", "Bug", "MEDIUM");

        mvc.perform(MockMvcRequestBuilders.put("/api/v1/customer/ticket/"+ticketId)
                        .header("Authorization", "Bearer " + jwtToken)
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(mapper.writeValueAsString(updateDto)))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.message").value("Ticket Updated Successfully"));
    }

    @Test
    void deleteTicket() throws Exception{
        mvc.perform(MockMvcRequestBuilders.delete("/api/v1/customer/ticket/"+ticketId)
                        .header("Authorization", "Bearer " + jwtToken))
                .andExpect(status().isNoContent())
                .andExpect(jsonPath("$.message").value("Ticket Deleted Successfully"));
    }
}
--------------------------cust
package com.example.CustomerSupportTicket.controllers;

import com.example.CustomerSupportTicket.dtos.requestdto.LoginReqDto;
import com.example.CustomerSupportTicket.dtos.requestdto.RegisterRequestDto;
import com.example.CustomerSupportTicket.dtos.requestdto.TicketReqDto;
import com.example.CustomerSupportTicket.models.TicketType;
import com.example.CustomerSupportTicket.repositories.TicketTypeRepository;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.http.MediaType;
import org.springframework.test.context.ActiveProfiles;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.test.web.servlet.request.MockMvcRequestBuilders;

import static org.junit.jupiter.api.Assertions.*;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;


@SpringBootTest
@AutoConfigureMockMvc
@ActiveProfiles("test")
public class UserControllerTest {
    @Autowired
    private MockMvc mvc;

    @Autowired
    private ObjectMapper mapper;
    @Autowired
    private TicketTypeRepository ticketTypeRepository;

    private String jwtToken;
    private Long ticketId;
    @BeforeEach
    void setup() throws Exception {
        // Ensure TicketType "Bug" exists
        if (ticketTypeRepository.findByType("Bug") == null) {
            TicketType bugType = TicketType.builder()
                    .type("Bug")
                    .build();
            ticketTypeRepository.save(bugType);
        }
        var registerDto = new RegisterRequestDto("Customer User", "customer@example.com", "cust123", "Bhaktapur", "9808888888");
        mvc.perform(MockMvcRequestBuilders.post("/api/v1/auth/create-user")
                .contentType(MediaType.APPLICATION_JSON)
                .content(mapper.writeValueAsString(registerDto)));

        var loginDto = new LoginReqDto("customer@example.com", "cust123");
        var loginResponse = mvc.perform(MockMvcRequestBuilders.post("/api/v1/auth/login")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(mapper.writeValueAsString(loginDto)))
                .andReturn().getResponse().getContentAsString();

        jwtToken = mapper.readTree(loginResponse).get("data").get("token").asText();
        // Create a new ticket
        var ticketDto = new TicketReqDto("Test Ticket", "This is a test", "Bug", "HIGH");
        var createResponse = mvc.perform(MockMvcRequestBuilders.post("/api/v1/ticket")
                        .header("Authorization", "Bearer " + jwtToken)
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(mapper.writeValueAsString(ticketDto)))
                .andReturn().getResponse().getContentAsString();
        System.out.println("Create Response: " + createResponse);

        // Save created ticket ID for use in tests
        ticketId = mapper.readTree(createResponse).get("data").get("id").asLong();
    }
    @Test
    void getAllTicket() throws Exception{
        mvc.perform(MockMvcRequestBuilders.get("/api/v1/customer/tickets")
                        .header("Authorization", "Bearer " + jwtToken))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.message").exists());
    }

    @Test
    void getTicketById() throws Exception{
        mvc.perform(MockMvcRequestBuilders.get("/api/v1/customer/ticket/"+ticketId)
                        .header("Authorization", "Bearer " + jwtToken))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.message").value("Ticket fetch Success"));

    }

    @Test
    void updateTicket() throws Exception{
        var updateDto = new TicketReqDto("Updated Title", "Updated Description", "Bug", "MEDIUM");

        mvc.perform(MockMvcRequestBuilders.put("/api/v1/customer/ticket/"+ticketId)
                        .header("Authorization", "Bearer " + jwtToken)
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(mapper.writeValueAsString(updateDto)))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.message").value("Ticket Updated Successfully"));
    }

    @Test
    void deleteTicket() throws Exception{
        mvc.perform(MockMvcRequestBuilders.delete("/api/v1/customer/ticket/"+ticketId)
                        .header("Authorization", "Bearer " + jwtToken))
                .andExpect(status().isNoContent())
                .andExpect(jsonPath("$.message").value("Ticket Deleted Successfully"));
    }
}


package com.example.CustomerSupportTicket.controllers;

import com.example.CustomerSupportTicket.dtos.requestdto.LoginReqDto;
import com.example.CustomerSupportTicket.dtos.requestdto.RegisterRequestDto;
import com.example.CustomerSupportTicket.dtos.requestdto.TicketReqDto;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.http.MediaType;
import org.springframework.test.context.ActiveProfiles;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.test.web.servlet.request.MockMvcRequestBuilders;

import static org.junit.jupiter.api.Assertions.*;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;

@SpringBootTest
@AutoConfigureMockMvc
@ActiveProfiles("test")
public class TicketControllerTest {
    @Autowired
    private MockMvc mvc;

    @Autowired
    private ObjectMapper mapper;

    private String jwtToken;
    @BeforeEach
    void setup() throws Exception {
        // Register admin user
        var registerDto = new RegisterRequestDto("Admin User", "admin@example.com", "admin123", "Kathmandu", "9800000000");
        mvc.perform(MockMvcRequestBuilders.post("/api/v1/auth/create-user")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(mapper.writeValueAsString(registerDto)))
                .andExpect(status().isCreated());

        // Login admin user
        var loginDto = new LoginReqDto("admin@example.com", "admin123");
        String loginContent = mapper.writeValueAsString(loginDto);
        var result = mvc.perform(MockMvcRequestBuilders.post("/api/v1/auth/login")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(loginContent))
                .andExpect(status().isOk())
                .andReturn();

        jwtToken = mapper.readTree(result.getResponse().getContentAsString())
                .get("data").get("token").asText();
    }

    @Test
    void createTicket() throws Exception{
        var ticketDto = new TicketReqDto("Title", "Desc", "Bug", "HIGH");

        mvc.perform(MockMvcRequestBuilders.post("/api/v1/ticket")
                        .header("Authorization", "Bearer " + jwtToken)
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(mapper.writeValueAsString(ticketDto)))
                .andExpect(status().isCreated())
                .andExpect(jsonPath("$.message").value("Ticket Created"));
    }
}



<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Advanced To-Do List</title>
  <link rel="stylesheet" href="style.css" />
</head>
<body>
  <div class="header">
    <h1>Today's To-Do List</h1>
    <p id="dateTime"></p>
  </div>

  <div class="controls">
    <input type="text" id="taskInput" placeholder="Enter task" />
    <input type="text" id="subtaskInput" placeholder="Subtask (optional)" />
    <input type="date" id="dueDateInput" />
    <select id="categorySelect">
      <option value="General">General</option>
      <option value="Work">Work</option>
      <option value="Personal">Personal</option>
    </select>
    <select id="prioritySelect">
      <option value="Low">Low</option>
      <option value="Medium" selected>Medium</option>
      <option value="High">High</option>
    </select>
    <button onclick="addTask()">Add Task</button>
    <select id="sortSelect" onchange="renderTasks()">
      <option value="newest">Newest</option>
      <option value="oldest">Oldest</option>
      <option value="priorityHighLow">Priority High ‚Üí Low</option>
      <option value="priorityLowHigh">Priority Low ‚Üí High</option>
    </select>
  </div>

  <div class="task-layout">
    <div class="task-column" id="uncompletedColumn">
      <h2>üìù Uncompleted Tasks</h2>
      <ul id="uncompletedList"></ul>
    </div>
    <div class="task-column" id="completedColumn">
      <h2>‚úÖ Completed Tasks</h2>
      <ul id="completedList"></ul>
    </div>
  </div>

  <script src="script.js"></script>
</body>
</html>



body {
  margin: 0;
  font-family: 'Segoe UI', sans-serif;
  background: linear-gradient(to right, #dfe9f3, #ffffff);
  padding: 20px;
}

.header {
  text-align: center;
}

#dateTime {
  color: #444;
  font-size: 14px;
}

.controls {
  display: flex;
  flex-wrap: wrap;
  gap: 10px;
  margin: 20px auto;
  justify-content: center;
}

.controls input,
.controls select,
.controls button {
  padding: 10px;
  border-radius: 6px;
  border: 1px solid #ccc;
  min-width: 150px;
}

.controls button {
  background-color: #4CAF50;
  color: white;
  cursor: pointer;
  border: none;
}

.task-layout {
  display: flex;
  justify-content: space-between;
  gap: 20px;
  margin-top: 30px;
}

.task-column {
  flex: 1;
  background-color: #ffffff;
  padding: 20px;
  border-radius: 10px;
  box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
  min-height: 300px;
}

ul {
  list-style: none;
  padding: 0;
}

li {
  background-color: #f9f9f9;
  margin-bottom: 10px;
  padding: 12px;
  border-left: 6px solid #ccc;
  border-radius: 6px;
}

li.completed {
  background-color: #e0ffe0;
  text-decoration: line-through;
  color: gray;
}

.priority-High { border-left-color: #e53935; }
.priority-Medium { border-left-color: #ffb300; }
.priority-Low { border-left-color: #43a047; }

.task-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.task-buttons button {
  margin-left: 6px;
  padding: 4px 8px;
  font-size: 12px;
  border: none;
  border-radius: 4px;
  cursor: pointer;
}

.edit-btn { background-color: #1976d2; color: white; }
.delete-btn { background-color: #d32f2f; color: white; }

.task-details {
  font-size: 13px;
  color: #555;
  margin-top: 5px;
}

.category-General { color: #333; }
.category-Work { color: #00796b; font-weight: bold; }
.category-Personal { color: #6a1b9a; font-weight: bold; }

.subtask {
  font-size: 12px;
  margin-top: 4px;
  padding-left: 10px;
  color: #666;
}


let tasks = [];

window.onload = () => {
  updateDateTime();
  loadTasks();
  renderTasks();
  setInterval(updateDateTime, 1000);
};

function updateDateTime() {
  const now = new Date();
  document.getElementById("dateTime").innerText = now.toLocaleString();
}

function addTask() {
  const text = document.getElementById("taskInput").value.trim();
  const subtask = document.getElementById("subtaskInput").value.trim();
  const dueDate = document.getElementById("dueDateInput").value;
  const priority = document.getElementById("prioritySelect").value;
  const category = document.getElementById("categorySelect").value;

  if (!text) {
    alert("Please enter a task.");
    return;
  }

  tasks.push({
    text,
    subtask,
    dueDate,
    category,
    priority,
    completed: false,
    createdAt: new Date().toISOString()
  });

  document.getElementById("taskInput").value = "";
  document.getElementById("subtaskInput").value = "";
  document.getElementById("dueDateInput").value = "";

  saveTasks();
  renderTasks();
}

function renderTasks() {
  const uncompletedList = document.getElementById("uncompletedList");
  const completedList = document.getElementById("completedList");
  const sortType = document.getElementById("sortSelect").value;

  uncompletedList.innerHTML = "";
  completedList.innerHTML = "";

  let sortedTasks = [...tasks];

  if (sortType === "newest") {
    sortedTasks.sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));
  } else if (sortType === "oldest") {
    sortedTasks.sort((a, b) => new Date(a.createdAt) - new Date(b.createdAt));
  } else if (sortType === "priorityHighLow") {
    const order = { High: 3, Medium: 2, Low: 1 };
    sortedTasks.sort((a, b) => order[b.priority] - order[a.priority]);
  } else if (sortType === "priorityLowHigh") {
    const order = { High: 3, Medium: 2, Low: 1 };
    sortedTasks.sort((a, b) => order[a.priority] - order[b.priority]);
  }

  sortedTasks.forEach((task, index) => {
    const li = document.createElement("li");
    li.className = `${task.completed ? "completed" : ""} priority-${task.priority}`;

    const categoryClass = `category-${task.category}`;

    li.innerHTML = `
      <div class="task-header">
        <div>
          <input type="checkbox" ${task.completed ? "checked" : ""} onchange="toggleComplete(${index})" />
          <strong>${task.text}</strong>
        </div>
        <div class="task-buttons">
          <button class="edit-btn" onclick="editTask(${index})">Edit</button>
          <button class="delete-btn" onclick="deleteTask(${index})">Delete</button>
        </div>
      </div>
      <div class="task-details">
        <span class="${categoryClass}">üìÅ ${task.category}</span> | 
        üóì Due: ${task.dueDate || 'N/A'} | 
        ‚è≥ Priority: ${task.priority}
      </div>
      ${task.subtask ? `<div class="subtask">üîπ Subtask: ${task.subtask}</div>` : ""}
    `;

    task.completed
      ? completedList.appendChild(li)
      : uncompletedList.appendChild(li);
  });
}

function toggleComplete(index) {
  tasks[index].completed = !tasks[index].completed;
  saveTasks();
  renderTasks();
}

function editTask(index) {
  const newText = prompt("Edit task:", tasks[index].text);
  if (newText !== null && newText.trim() !== "") {
    tasks[index].text = newText.trim();
    saveTasks();
    renderTasks();
  }
}

function deleteTask(index) {
  if (confirm("Are you sure you want to delete this task?")) {
    tasks.splice(index, 1);
    saveTasks();
    renderTasks();
  }
}

function saveTasks() {
  localStorage.setItem("tasks", JSON.stringify(tasks));
}

function loadTasks() {
  const data = localStorage.getItem("tasks");
  if (data) {
    tasks = JSON.parse(data);
  }
}

